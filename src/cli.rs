use std::collections::HashSet;

use anyhow::Result;
use clap::{Parser, Subcommand};
use colored::Colorize;
use inquire::{Select, Text};

use crate::config::AppConfig;
use crate::preset::LlmPresetFields;
use crate::ui;

#[derive(Parser, Debug)]
#[command(
    name = "cgen",
    about = "Generate git commit messages via LLMs",
    version,
    after_help = "Any arguments after `cgen` (without a subcommand) are forwarded to `git commit`."
)]
pub struct Cli {
    #[command(subcommand)]
    pub command: Option<Command>,

    /// Generate and print commit message without creating a commit
    #[arg(long)]
    pub dry_run: bool,

    /// Print the final system prompt sent to the LLM (without diff payload)
    #[arg(long)]
    pub verbose: bool,

    /// Create a semantic version tag after a successful commit
    #[arg(long)]
    pub tag: bool,

    /// Extra arguments forwarded to `git commit`
    #[arg(trailing_var_arg = true, allow_hyphen_values = true)]
    pub extra_args: Vec<String>,
}

#[derive(Subcommand, Debug)]
pub enum Command {
    /// Open interactive configuration editor
    Config,
    /// Undo latest commit (soft reset)
    Undo,
    /// Generate message from existing commit diff and rewrite commit message
    Alter {
        /// One hash: rewrite that commit from its own diff. Two hashes: use older..newer diff and rewrite newer.
        #[arg(value_name = "HASH", num_args = 1..=2)]
        commits: Vec<String>,
    },
    /// Update cgen to the latest version
    Update,
    /// Print the LLM system prompt without running anything
    Prompt,
    /// View commit history generated by cgen
    History,
    /// Manage LLM presets (save, load, rename, duplicate, delete, export/import)
    Preset,
    /// Configure LLM fallback order
    Fallback,
}

pub fn parse() -> Cli {
    Cli::parse()
}

/// What happens when a menu entry is selected
enum MenuAction {
    ToggleGroup(&'static str),
    ToggleSubgroup(&'static str),
    EditField(&'static str),
    SaveAsPreset,
    LoadPreset,
    ManagePresets,
    ManageFallbackOrder,
    ToggleDescriptions,
    Search,
}

pub fn interactive_config(global: bool) -> Result<()> {
    let mut cfg = AppConfig::load()?;
    let scope = if global { "global" } else { "local" };

    println!("\n{}  {} configuration\n", "cgen".cyan().bold(), scope);

    let mut expanded: HashSet<&str> = HashSet::new();
    expanded.insert("Basic");

    let mut cursor_target: Option<&str> = None;
    let mut first_render = true;

    // Preset tracking state
    let mut loaded_preset_id: Option<u32> = None;
    let mut loaded_preset_snapshot: Option<LlmPresetFields> = None;

    // Description toggle (resets each session)
    let mut show_descriptions = false;

    loop {
        if first_render {
            first_render = false;
        } else {
            print!("\x1B[2J\x1B[H");
            println!("\n{}  {} configuration\n", "cgen".cyan().bold(), scope);
        }

        // Show preset modification warning
        let preset_modified = if let Some(ref snapshot) = loaded_preset_snapshot {
            crate::preset::preset_is_modified(&cfg, snapshot)
        } else {
            false
        };
        if preset_modified {
            println!("  {}", "(preset modified)".dimmed());
        }

        let groups = cfg.grouped_fields();
        let mut actions: Vec<MenuAction> = Vec::new();
        let mut labels: Vec<String> = Vec::new();

        for group in &groups {
            let group_open = expanded.contains(group.name);
            let arrow = if group_open { "\u{25BC}" } else { "\u{25B6}" };
            labels.push(format!("{} {}", arrow, group.name.bright_white().bold()));
            actions.push(MenuAction::ToggleGroup(group.name));

            if !group_open {
                continue;
            }

            let has_subgroups = !group.subgroups.is_empty();
            for (i, (display_name, suffix, val)) in group.fields.iter().enumerate() {
                let is_last = !has_subgroups && i == group.fields.len() - 1;
                let conn = if is_last { "\u{2514}\u{2500}\u{2500}" } else { "\u{251C}\u{2500}\u{2500}" };
                let mut field_label = format!("  {} {:<22} {}", conn, display_name, val.dimmed());
                if show_descriptions {
                    let desc = crate::config::field_description(suffix);
                    if !desc.is_empty() {
                        field_label.push_str(&format!("\n      {}", desc.bright_black()));
                    }
                }
                labels.push(field_label);
                actions.push(MenuAction::EditField(suffix));
            }

            for (sg_idx, sg) in group.subgroups.iter().enumerate() {
                let is_last_sg = sg_idx == group.subgroups.len() - 1;
                let sg_open = expanded.contains(sg.name);
                let sg_arrow = if sg_open { "\u{25BC}" } else { "\u{25B6}" };
                let sg_conn = if is_last_sg { "\u{2514}\u{2500}\u{2500}" } else { "\u{251C}\u{2500}\u{2500}" };
                labels.push(format!("  {} {} {}", sg_conn, sg_arrow, sg.name.bright_cyan().bold()));
                actions.push(MenuAction::ToggleSubgroup(sg.name));

                if !sg_open {
                    continue;
                }

                let pipe = if is_last_sg { " " } else { "\u{2502}" };
                for (f_idx, (display_name, suffix, val)) in sg.fields.iter().enumerate() {
                    let is_last_field = f_idx == sg.fields.len() - 1;
                    let f_conn = if is_last_field { "\u{2514}\u{2500}\u{2500}" } else { "\u{251C}\u{2500}\u{2500}" };
                    let mut field_label = format!(
                        "  {}   {} {:<22} {}",
                        pipe, f_conn, display_name, val.dimmed()
                    );
                    if show_descriptions {
                        let desc = crate::config::field_description(suffix);
                        if !desc.is_empty() {
                            field_label.push_str(&format!("\n          {}", desc.bright_black()));
                        }
                    }
                    labels.push(field_label);
                    actions.push(MenuAction::EditField(suffix));
                }
            }
        }

        // Preset/fallback menu entries
        let current_fields = crate::preset::fields_from_config(&cfg);
        let has_matching_preset = crate::preset::load_presets()
            .ok()
            .and_then(|f| crate::preset::find_duplicate(&f, &current_fields))
            .is_some();

        if !has_matching_preset {
            labels.push("Save current as preset".cyan().to_string());
            actions.push(MenuAction::SaveAsPreset);
        }

        labels.push("Load a preset".cyan().to_string());
        actions.push(MenuAction::LoadPreset);

        labels.push("Manage presets...".cyan().to_string());
        actions.push(MenuAction::ManagePresets);

        labels.push("Configure fallback order...".cyan().to_string());
        actions.push(MenuAction::ManageFallbackOrder);

        // Toggle descriptions menu item
        let desc_label = if show_descriptions {
            "Hide descriptions [?]".bright_yellow().to_string()
        } else {
            "Show descriptions [?]".bright_yellow().to_string()
        };
        labels.push(desc_label);
        actions.push(MenuAction::ToggleDescriptions);

        // Search menu item
        labels.push("Search settings [/]".bright_yellow().to_string());
        actions.push(MenuAction::Search);

        // Resolve starting cursor position from previous toggle target
        let starting_cursor = cursor_target
            .and_then(|target| {
                actions.iter().position(|a| matches!(
                    a,
                    MenuAction::ToggleGroup(n) | MenuAction::ToggleSubgroup(n) if *n == target
                ))
            })
            .unwrap_or(0);
        cursor_target = None;

        let mut all_labels = labels.clone();
        all_labels.push("Save & Exit".green().to_string());
        all_labels.push("Exit without saving".red().to_string());

        let selection = Select::new("Edit a setting:", all_labels)
            .with_page_size(22)
            .with_starting_cursor(starting_cursor)
            .with_formatter(&|opt| ui::strip_tree_chars(opt.value))
            .prompt();

        let selection = match selection {
            Ok(s) => s,
            Err(_) => break,
        };

        if selection.contains("Save & Exit") {
            // If preset was loaded and modified, offer to update it
            if preset_modified {
                if let Some(pid) = loaded_preset_id {
                    let _ = crate::preset::prompt_update_preset(&cfg, pid);
                }
            }

            if global {
                cfg.save_global()?;
                let path = crate::config::global_config_path()
                    .map(|p| p.display().to_string())
                    .unwrap_or_default();
                println!("\n{} Saved to {}", "done!".green().bold(), path.dimmed());
            } else {
                cfg.save_local()?;
                println!("\n{} Saved to {}", "done!".green().bold(), ".env".dimmed());
            }
            break;
        }
        if selection.contains("Exit without saving") {
            println!("{}", "Cancelled.".dimmed());
            break;
        }

        let idx = labels.iter().position(|l| selection.contains(l.as_str()));
        let idx = match idx {
            Some(i) => i,
            None => continue,
        };

        match &actions[idx] {
            MenuAction::ToggleGroup(name) => {
                if expanded.contains(name) {
                    expanded.remove(name);
                    let groups = cfg.grouped_fields();
                    if let Some(g) = groups.iter().find(|g| g.name == *name) {
                        for sg in &g.subgroups {
                            expanded.remove(sg.name);
                        }
                    }
                } else {
                    expanded.insert(name);
                }
                cursor_target = Some(name);
            }
            MenuAction::ToggleSubgroup(name) => {
                if expanded.contains(name) {
                    expanded.remove(name);
                } else {
                    expanded.insert(name);
                }
                cursor_target = Some(name);
            }
            MenuAction::EditField(suffix) => {
                let new_value = edit_field(suffix, &cfg);
                if let Some(val) = new_value {
                    if let Err(err) = cfg.set_field(suffix, &val) {
                        println!("  {} {}", "error:".red().bold(), err);
                        continue;
                    }
                    if *suffix == "PROVIDER" {
                        let default_model = crate::provider::default_model_for(&val);
                        cfg.set_field("MODEL", default_model)?;
                        if default_model.is_empty() {
                            println!(
                                "  {} Model cleared (set it manually)",
                                "note:".yellow().bold()
                            );
                        } else {
                            println!(
                                "  {} Model set to {}",
                                "note:".yellow().bold(),
                                default_model.dimmed()
                            );
                        }
                    }
                }
            }
            MenuAction::SaveAsPreset => {
                let _ = crate::preset::save_current_as_preset(&cfg);
            }
            MenuAction::LoadPreset => {
                match crate::preset::select_and_load_preset(&mut cfg) {
                    Ok(Some((id, snapshot))) => {
                        loaded_preset_id = Some(id);
                        loaded_preset_snapshot = Some(snapshot);
                    }
                    Ok(None) => {}
                    Err(e) => println!("  {} {}", "error:".red().bold(), e),
                }
            }
            MenuAction::ManagePresets => {
                let _ = crate::preset::interactive_presets();
            }
            MenuAction::ManageFallbackOrder => {
                let _ = crate::preset::interactive_fallback_order();
            }
            MenuAction::ToggleDescriptions => {
                show_descriptions = !show_descriptions;
            }
            MenuAction::Search => {
                if let Some(query) = Text::new("Search:")
                    .with_help_message("Enter text to search for in setting names")
                    .prompt()
                    .ok()
                {
                    let query_lower = query.to_lowercase();
                    if !query_lower.is_empty() {
                        // Search all fields across all groups and auto-expand matching groups
                        let groups = cfg.grouped_fields();
                        for group in &groups {
                            let group_has_match = group.fields.iter().any(|(name, _, _)| {
                                name.to_lowercase().contains(&query_lower)
                            });
                            if group_has_match {
                                expanded.insert(group.name);
                            }

                            for sg in &group.subgroups {
                                let sg_has_match = sg.fields.iter().any(|(name, _, _)| {
                                    name.to_lowercase().contains(&query_lower)
                                });
                                if sg_has_match {
                                    expanded.insert(group.name);
                                    expanded.insert(sg.name);
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    Ok(())
}

fn edit_field(suffix: &str, cfg: &AppConfig) -> Option<String> {
    match suffix {
        "PROVIDER" => {
            let choices = vec![
                "gemini",
                "openai",
                "anthropic",
                "groq",
                "grok",
                "deepseek",
                "openrouter",
                "mistral",
                "together",
                "fireworks",
                "perplexity",
                "(custom)",
            ];
            match Select::new("Provider:", choices).prompt() {
                Ok("(custom)") => Text::new("Custom provider name:").prompt().ok(),
                Ok(v) => Some(v.to_string()),
                Err(_) => None,
            }
        }
        "ONE_LINER" => {
            let choices = vec!["enabled", "disabled"];
            Select::new("One-liner commits:", choices)
                .prompt()
                .ok()
                .map(|v| if v == "enabled" { "1" } else { "0" }.to_string())
        }
        "USE_GITMOJI" => {
            let choices = vec!["disabled", "enabled"];
            Select::new("Use Gitmoji:", choices)
                .prompt()
                .ok()
                .map(|v| if v == "enabled" { "1" } else { "0" }.to_string())
        }
        "GITMOJI_FORMAT" => {
            let choices = vec!["unicode", "shortcode"];
            Select::new("Gitmoji format:", choices)
                .prompt()
                .ok()
                .map(|v| v.to_string())
        }
        "REVIEW_COMMIT" => {
            let choices = vec!["disabled", "enabled"];
            Select::new("Review commit before confirming:", choices)
                .prompt()
                .ok()
                .map(|v| if v == "enabled" { "1" } else { "0" }.to_string())
        }
        "POST_COMMIT_PUSH" => {
            let choices = vec!["ask", "always", "never"];
            Select::new("Post-commit push behavior:", choices)
                .prompt()
                .ok()
                .map(|v| v.to_string())
        }
        "SUPPRESS_TOOL_OUTPUT" => {
            let choices = vec!["disabled", "enabled"];
            Select::new("Suppress git command output:", choices)
                .prompt()
                .ok()
                .map(|v| if v == "enabled" { "1" } else { "0" }.to_string())
        }
        "WARN_STAGED_FILES_ENABLED" => {
            let choices = vec!["enabled", "disabled"];
            Select::new("Warn when staged files exceed threshold:", choices)
                .prompt()
                .ok()
                .map(|v| if v == "enabled" { "1" } else { "0" }.to_string())
        }
        "WARN_STAGED_FILES_THRESHOLD" => Text::new("Warn threshold (staged files count):")
            .with_help_message(
                "Integer value; warning shows when count is greater than this threshold",
            )
            .prompt()
            .ok(),
        "CONFIRM_NEW_VERSION" => {
            let choices = vec!["enabled", "disabled"];
            Select::new("Confirm new semantic version tag:", choices)
                .prompt()
                .ok()
                .map(|v| if v == "enabled" { "1" } else { "0" }.to_string())
        }
        "AUTO_UPDATE" => {
            let choices = vec!["enabled", "disabled"];
            Select::new("Enable automatic updates:", choices)
                .prompt()
                .ok()
                .map(|v| if v == "enabled" { "1" } else { "0" }.to_string())
        }
        "FALLBACK_ENABLED" => {
            let choices = vec!["enabled", "disabled"];
            Select::new("Enable LLM fallback on failure:", choices)
                .prompt()
                .ok()
                .map(|v| if v == "enabled" { "1" } else { "0" }.to_string())
        }
        "TRACK_GENERATED_COMMITS" => {
            let choices = vec!["enabled", "disabled"];
            Select::new("Track AI-generated commits:", choices)
                .prompt()
                .ok()
                .map(|v| if v == "enabled" { "1" } else { "0" }.to_string())
        }
        "API_KEY" => Text::new("API Key:")
            .with_help_message("Your LLM provider API key")
            .prompt()
            .ok(),
        "DIFF_EXCLUDE_GLOBS" => Text::new("Diff Exclude Globs:")
            .with_help_message("Comma-separated glob patterns (e.g., *.json,*.lock,*.png)")
            .with_default(&cfg.diff_exclude_globs.join(","))
            .prompt()
            .ok(),
        _ => {
            let fields = cfg.fields_display();
            let field = fields.iter().find(|(_, s, _)| *s == suffix);
            match field {
                Some((name, _, val)) => {
                    let prompt_text = format!("{}:", name);
                    Text::new(&prompt_text).with_default(val).prompt().ok()
                }
                None => None,
            }
        }
    }
}
